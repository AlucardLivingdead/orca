#!/bin/sh
#
# Orca
#
# Copyright 2006 Sun Microsystems Inc.
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Library General Public
# License as published by the Free Software Foundation; either
# version 2 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Library General Public License for more details.
#
# You should have received a copy of the GNU Library General Public
# License along with this library; if not, write to the
# Free Software Foundation, Inc., 59 Temple Place - Suite 330,
# Boston, MA 02111-1307, USA.

# This script performs some clean up and will run Orca.  It will also
# rerun Orca if it detects that Orca died an unnatural death.

# __id__        = "$Id$"
# __version__   = "$Revision$"
# __date__      = "$Date$"
# __copyright__ = "Copyright (c) 2005-2006 Sun Microsystems Inc."
# __license__   = "LGPL"

# [[[TODO: WDW - this is experimental and disabled by default.  If you
# want to try the full blown functionality, comment out the RUNONCE
# line below.  Beware that it NEEDS A LOT OF WORK AND REALLY ISN'T
# WORKING YET.  If you leave RUNONCE as it is, then this will just
# run Orca once and quit.]]]
#
RUNONCE="true"

# A value of 1 means to run Orca.  A value of 0 means quit.
#
RUN=1

# The watchdog will periodically ping Orca to see if it is responding.
# If orca isn't responding, the watchdog will kill the Orca process.
# The watchdog logic requires 'wget', so we won't do it if we can't
# find wget in the path.  Note also that you can force WATCHDOG=0 if you
# do not want a background process that periodically pings Orca to see
# if it is responding.
#
WGETCMD=`which wget`
if [ "x$WGETCMD" = "x" ]
then
    WATCHDOG=0
else
    WATCHDOG=1
fi

# Cleans up any orca-related processes that might be running,
# restricting it to those processes owned by the user. These include
# orca itself, any gnome-speech synthesis drivers, and festival
# processes running in server mode.
#
cleanup()
{
    USERID=`id | cut -f2 -d= | cut -f1 -d\(`
    PIDS=`ps -eo pid,ruid,args | grep $USERID | egrep "orca[.]orca|synthesis-driver|festival [-][-]server" | grep -v grep | awk '{ print $1 }'`

    if [ "x$PIDS" != "x" ]
    then
        kill -9 $PIDS > /dev/null
    fi
}

# Runs orca.
#
runOrca()
{
    cleanup
    exec_prefix=@prefix@
    PYTHONPATH=@pyexecdir@
    export PYTHONPATH
    @PYTHON@ -c "import orca.orca; orca.orca.main()" "$*"
}

# Runs a watchdog process in the background.  It merely attempts to
# get to Orca via some other means than the AT-SPI.  Here we use
# Orca's http server at port 20433.  If it doesn't respond, then
# we assume Orca is dead.
#
# [[[TODO: Don't know how to make this die when the script is killed.
# It seems to want to run as a nohup process.  There's also a possible
# race condition here where the main loop might have just called runOrca
# and this watchdog might come back from its sleep and catch things at
# such a time where Orca isn't responding yet.]]]
#
watchdog()
{
    (
        sleep 30 # Give orca a chance to start.
        while [ "$WATCHDOG" -gt 0 ]
        do
            sleep 5
            USERID=`id | cut -f2 -d= | cut -f1 -d\(`
            PID=`ps -eo pid,ruid,args | grep $USERID | egrep "orca[.]orca" | grep -v grep | awk '{ print $1 }'`

            if [ "x$PID" = "x" ]
            then
                exit
            else
                if ! $WGETCMD -q -t 0 -O /dev/null -w 2 localhost:20433
                then
                    echo Orca watchdog detected something bad.  Cleaning up.
                    cleanup
                fi
            fi
        done
    ) &
}

main()
{
    if [ "$WATCHDOG" -gt 0 ]
    then
        watchdog
    fi
    while [ "$RUN" -gt 0 ]
    do
        runOrca
        RUN=$?  # quit on a normal exit status from Orca
    done
}

if [ "x$RUNONCE" = "x" ]
then
    main
else
    runOrca "$*"
fi
