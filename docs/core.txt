The Orca Core Module

Overview
==========
Orca's core module connects it to at-spi.  It exposes various
functions and two types of objects:

* core.Accessible - wraps the Accessible interface and does property
  caching
* core.Event - appears exactly as if it were an at-spi event, but
  contains a core.Accessible as the event source

The core uses a few internal data structures and objects worth noting:

* EventListener - objects of this type are registered as at-spi event
  listeners.  They contain both a list of C functions, and a list of
  Python functions to be called when an event of their type occurs.
  Only one EventListener object for each at-si event type is
  registered at once.  This allows clients to be assured that all
  event dispatching happens in the order in which the listeners were
  registered.
* EventQueue - This object queues events to be dispatched to clients.
  When an EventListener object is notified of an at-spi event, it
  posts the at-spi event to an event queue object.  the EventQueue
  object then dispatches the queued events in an idle handler.

Registering for Event Notifications
==========
Clients register their interest in being notified of certain events
with the core module by using the registerEventListener function.  The
function takes two arguments - a reference to the function to be
called when the event occurs, and the name of the at-spi event.  For
example:

core.registerEventListener (onFocus, "focus:")

Event listeners are unregistered with theunregisterEventListener
function.  It takes the same form as the registerEventListener
function.  For example:

core.unregisterEventListener (onFocus, "focus:")

Tracing event flow
=========
As an example of how events flow through the core module, a focus
event takes the following path through the core module:

* Upon initialization, the core creates a global event queue
* The client registers interest in focus events:
  core.registerEventListener (onFocus, "focus:")
* A new internal EventListener object is created in the core, and a
  reference to the client's onFocus function is added to its list of
  Python functions
* The application generates a focus event
* The at-spi registry notify's the core's internal focus event
  listener that the focus event has occurred
* The focus event listener posts the at-spi event to the global event
  queue
* This causes an idle handler to be registered if one isn't already
* On idle, the focus event is removed from the queue
* A core.Event object is created using the at-spi focus event, and all
  the focus EventListener's C and Python functions are called, passing
  the core.Event object as their only parameter

The core.Accessible object
==========
The core module includes an object called core.Accessible.  This
object wraps all the methods exposed by at-spi Accessible objects.
The core module also includes logic to cache core.Accessible objects.
Internally, the core module calles pyaccessible_new, passing it the
CORBA object reference to the at-spi accessible object.
Pyaccessible_new returns a pyaccessible (which is the internal name
for core.Accesible) object which wraps the specified at-spi accessible
object.  Note that the core module has an internal cache of all the
currently active core.Accessible objects - and will simply ref and
return an existing core.Accessible object if one has already been
created for the specified at-spi accessible object.  This ensures
that, for example (obj.getChildAtIndex(0).parent == obj)

As well as wrapping at-spi accessible methods, core.Accessible also
does property caching.  The rollowing properties are cached:

* Accessible name
* Accessible description
* Role Name
* Localized Role Name
* Parent
* Accessible State set

Thus, for example, when the client asks for the name of a
core.Accessible, the following things occur:

* Check to see if a name is already stored in the core.Accessible
  object's property cache.
* If so, ref and return it
* If not, call the at-spi accessible's get name method
* Store the name in the core.Accessible's cache
* Return the name

The same basic procedure is followed for all cached properties of
core.Acccessible objects.

The cached values of properties are invalidated by various internal
event listeners in the core module.  For example, the name property is
invalidated by "object:property-change:accessible-name".  (See the
pyaccessible_get_xxx functions in pyaccessible.c for a complete list
of the cached properties and the event handlers in coremodule.c which
invalidate them)

